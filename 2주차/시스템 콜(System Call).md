## 박상윤
### 시스템 콜

### 운영체제

- 컴퓨터의 자원들을 **효율적으로 관리**하며 **사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공**하는  여러 프로그램의 모임
    
    ![image 9](https://github.com/user-attachments/assets/02b7551c-5db7-435d-8f62-a8d5923cad03)

- 운영체제는 2개로 나뉘는데 운영체제의 핵심기능을 모아놓은 **커널,** 커널에 명령를 전달하고 실행 결과를 사용자와 응용프로그램에 돌려주는 **인터페이스**

---

### 커널

- 운영체제의 핵심적인 기능을 모아놓은 것
- 자동차가 운영체제라고 한다면 커널은 엔진이 해당됨 → 자동차의 종류가 다양한 것처럼 운영체제의 종류는 다양하지만 **성능을 결정하는 것은 커널이 좌우**
- 운영체제는 규모가 큰 프로그램이므로 컴퓨터의 전원을 켰을 때, 모든 운영체제가 모두 메모리에 올라가면 메모리 공간이 낭비가 심할 것 → 운영체제 중 항상 필요한 부분만을 전원이 커짐과 동시에 메모리에 올려놓고, 나머지는 필요할 때 메모리에 올려서 사용 → **이때 메모리에 상주하는 운영체제의 부분이 커널(kernal)**
- **커널의 구성**
    - **프로세스 관리** : 프로세스의 CPU를 분배하고 작업에 필요한 제반 환경 제공
    - **메모리 관리** : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간 제공
    - **파일 시스템 관리** : 데이터를 저장하고 접근할 수 있는 인터페이스 제공
    - **입출력 관리** : 필요한 입출력 서비스 제공
    - **프로세스 간 통신 관리** : 공동 작업을 위한 각 프로세스 간 통신 환경 제공

---

### 인터페이스

- 커널에 **사용자의 명령을 전달**하고 **실행 결과를 사용자에게 알려주는** 역할
- 자동차로 따지면 핸들, 브레이크, 계기판 등에 비유됨
- 인터페이스는 같은 커널이어도 다른 인터페이스 형태로 제작 가능 → 다른 인터페이스가 장착되면 사용자에게 다른 운영체제로 보임
- 예시) 유닉스의 사용자 인터페이스는 쉘(shell) → 인터페이스에 따라 bash 쉘, C 쉘, T 쉘 등으로 나뉨

---

### CPU 모드

- CPU는 사용자 애플리케이션(User application)이 시스템을 손상시키는 것을 방지하기 위해 2가지 모드를 제공
- CPU에 있는 Mode bit로 모드를 구분하여 **0은 ‘커널모드(kernal mode)’, 1은 ‘사용자모드(user mode)’**로 나뉘어서 구동
- 파일 읽어오기, 파일 쓰기, 화면에 메세지 출력 등 많은 부분이 커널 모드를 사용
- **사용자 모드 (User Mode)**
    - 사용자 애플리케이션 코드가 실행
    - 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어(디스크, I/O 등)에 접근 불가
    - 접근하기 위해선 **‘시스템 콜(System Call)’**을 사용해야 함
- **커널 모드 (Kernal Mode)**
    - 운영체제(OS)가 CPU를 사용하는 모드
    - 시스템 콜을 통해 커널모드로 전환되며 OS는 **하드웨어를 제어하는 명령어(Privileged Instructions)**를 실행
    - Privileged Instructions는 사용자 모드에서 실행되면 exception이 발생
        
        ![image 10](https://github.com/user-attachments/assets/130be638-7f2d-41b9-964b-b58044b3205d)

- 위 그림과 같이 user process는 User Mode에서 실행되다가 **시스템 자원을 사용해야할 때 시스템 콜을 호출**해서 커널 모드로 전환되어 작업을 수행하고 완료 시 다시 \사용자 모드로 전환함

---

### 시스템 콜 (System call)

- OS는 다양한 서비스들을 수행하기 위해 하드웨어를 직접적으로 관리
- 응용 프로그램은 OS가 제공하는 인터페이스를 통해서만 자원을 사용
- **OS가 제공하는 이러한 인터페이스를 ‘시스템 콜(System Call)’이라고 함**
- 일반 애플리케이션은 오직 시스템 콜을 통해서만 하드웨어나 시스템 자원 접근 가능 → **운영체제의 보안과 안정성을 유지할 수 있음**
- 보통 직접적으로 시스템콜을 사용하기보다는 API(라이브러리 함수)를 통해 사용하게 됨(예시 : standard C Library)

---

### 시스템 콜의 역할

- **자원 관리**
    - 파일 시스템, 네트워크, 프로세스, 메모리 등 다양한 시스템 자원을 관리하기 위한 기능을 제공
    - 예시) 파일을 열거나 읽고 쓰는 작업은 시스템 콜을 통해 이루어짐
- **보안과 안정성**
    - 사용자 프로그램이 직접 하드웨어에 접근하지 못하도록 하여, 잘못된 코드나 악의적인 코드가 시스템 전체에 영향을 미치지 않도록 보호
- **하드웨어 추상화**
    - 운영체제는 다양한 하드웨어의 복잡성을 숨기고, 일관된 인터페이스를 제공하여 프로그래머가 복잡한 하드웨어 제어 없이도 기능을 사용할 수 있게 함

---

### 시스템 콜의 동작 원리

![image 10](https://github.com/user-attachments/assets/b4282aa5-8854-418d-b3f9-9b1de7e7d19f)

1. **요청**
    - 사용자 프로그램이 API 호출하면, 내부적으로 적절한 시스템 콜을 준비
2. **모드 전환**
    - 시스템 콜을 실행하기 위해 CPU는 사용자 모드에서 커널 모드로 전환
    - 이 과정은 보통 인터럽트(interrupt)나 트랩(trap)을 이용하여 이루어짐
        - 인터럽트(interrupt) : 비동기적 CPU 이벤트를 처리하기 위한 기법(예시 - 네트워크 패킷 도착 이벤트, I/O 요청)
        - 트랩(trap) : 동기적 CPU 이벤트를 처리하기 위한 기법 (예시 - divide by zero)
3. **처리**
    - 커널은 요청된 작업을 수행하고, 필요한 경우 자원에 대한 접근 권한을 확인
4. **반환**
    - 작업 완료 후, 결과나 오류 코드를 사용자 프로그램으로 반환하면서 다시 사용자 모드로 전환

- 예시) C언어 환경에서 fork() 함수가 호출되는 과정

![KakaoTalk_20250305_205232908](https://github.com/user-attachments/assets/57c2e9d7-5fcf-4341-a791-ab4a74701733)

1. 사용자 프로세스에서 fork() 호출
2. C 라이브러리(libc) 내부에서 시스템 콜을 수행하기 위한 준비 과정
    - C 라이브러리 fork() 함수 내부에서 `movl $2, %eax; int $0x80;` 와 같은 명령어를 시스템 콜 번호를 EAX 레지스터에 넣고, 소프트웨어 인터럽트 `int 0x80` 을 발생시킴
3. `int 0x80`  인터럽트 벡터는 IDT(Interrupt Descriptor Table)의 **시스템 콜 처리 루틴**의 시작점 → Kernal 영역인 system_call() 내부로 진입
    - IDT(Interrupt Descriptor Table) : CPU가 인터럽트(HW 인터럽트, 예외, SW 인터럽트 등)를 처리할 때, 어떤 함수를 실행해야 하는지에 대한 주소(핸들러)를 저장하는 테이블
4. system_call() 에 진입하면, **커널 코드에서 추가적으로 레지스터를 저장**(SAVE_ALL) → 시스템 콜 처리 과정에서 레지스터가 변경되더라도, 원래 user process의 레지스터 상대를 복원할 수 있도록 하기 위함
5. 이후 커널은 EAX 레지스터를 확인하여, 어떤 시스템 콜 번호가 요청되었는지 파악
6. movl 2로 시스템 콜 번호가 2인 **시스템 콜 핸들러 함수 sys_fork() 가 호출**
    - sys_call_table : 시스템 콜 번호(EAX)에 따라 실제 처리 함수를 가리키는 함수 포인터 테이블
7. 시스템 콜 핸들러 함수가 종료되면, **system_call() 루틴은 저장해 두었던 레지스터 값을 복원**하고 사용자 모드로 복귀
8. 사용자 코드에는 시스템 콜의 결과값이 반환(return)되고 다음 명령 수행

---

### 시스템 콜의 종류 및 예시

- 시스템 콜은 크게 6가지로 분류
1. **프로세스 제어 (Process Control)**
    - 끝내기(exit), 중지 (abort)
    - 적재(load), 실행(execute)
    - 프로세스 생성(create process) - fork
    - 프로세스 속성 획득과 속성 설정
    - 시간 대기 (wait time)
    - 사건 대기 (wait event)
    - 사건을 알림 (signal event)
    - 메모리 할당 및 해제
2. **파일 조작 (File Manipulation)**
    - 파일 생성 / 삭제 (create, delete)
    - 열기 / 닫기 / 읽기 / 쓰기 (open, close, read, wirte)
    - 위치 변경 (reposition)
    - 파일 속성 획득 및 설정 (get file attribute, set file attribute)
3. **장치 관리 (Device Manipulation)**
    - 하드웨어의 제어와 상태 정보를 얻음 (ioctl)
    - 장치를 요구(request device), 장치를 방출 (relese device)
    - 읽기 (read), 쓰기(write), 위치 변경
    - 장치 속성 획득 및 설정
    - 장치의 논리적 부착 및 분리
4. **정보 유지 (Information Maintenance)**
    - getpid(), alarm(), sleep()
    - 시간과 날짜의 설정과 획득 (time)
    - 시스템 데이터의 설정과 획득 (date)
    - 프로세스 파일, 장치 속성의 획득 및 설정
5. **통신 (Communication)**
    - pipe(), shm_open(), mmap()
    - 통신 연결의 생성, 제거
    - 메시지의 송신, 수신
    - 상태 정보 전달
    - 원격 장치의 부착 및 분리
6. **보호 (Protection)**
    - chmod()
    - umask()
    - chown()
        
        ![image 11](https://github.com/user-attachments/assets/92ac7f9b-415e-4bee-936b-1bb8f31697dd)


---

### 성능 및 최적화 고려사항

- **오버헤드**
    - 시스템 콜은 사용자 모드와 커널 모드 사이의 전환이 필요 → 일반 함수 호출보다 오버헤드가 발생
    - 따라서 성능이 중요한 상황에서는 불필요한 시스템 콜 호출을 줄이기 위한 최적화 기법 필요
    - **오버헤드 감소를 위한 방법**
        - **시스템 콜의 호출 횟수를 최소화** - I/O 연산을 모아서 한 번에 처리 (예시 - write() 여러 번 호출 대신, 내부 버퍼에 모았다가 한 번에 write() 호출)
        - **고성능 API or 특별한 시스템 콜 사용** - sendfile(), splice() 와 같은 특수한 시스템 콜을 이용해, 사용자 공간을 거치지 않고 커널 내부에서 데이터를 직접 전송하여 오버헤드를 줄임
        - **적절한 라이브러리 함수 사용** - C 표준 라이브러리의 버퍼링 기능(stdio)이나 고수준 I/O 함수를 통해, 직접적인 시스템 콜 횟수를 줄일 수 있음
- **라이브러리 래핑**
    - 일반적으로 프로그래머는 시스템 콜을 직접 호출하기보다, C 표준 라이브러리나 다른 고수준 라이브러리 함수를 통해 커널에 접근 → 이 과정을 **래핑(wrapping)** 이라고 함
    - 고수준의 라이브러리 함수는 여러 시스템 콜을 내부적으로 호출할 수 있으며, 개발자는 이 과정을 신경 쓸 필요 없이 라이브러리 함수를 이용하여 작업 수행 가능 → 이로 인해 코드 가독성과 유지보수성이 좋아짐

---

### 보안 관점

- 시스템 콜은 커널 모드에서 실행되기 때문에, 올바르게 구현되지 않으면 보안 취약점이 될 수 있음
- 따라서 OS는 시스템 콜 인터페이스에 대해 **엄격한 검증과 권한 관리를 수행**
- 이를 통해 사용자 프로그램이 시스템 자원에 잘못 접근하는 것을 방지하고, 시스템 전체의 안정성 유지

---

### 결론

- 시스템 콜은 **사용자 프로그램과 OS 커널 간의 중요한 연결 고리**로, **다양한 자원 관리**와 **보안 기능**을 제공하는 핵심 인터페이스
- 이러한 시스템 콜의 이해는 **OS 내부 동작을 파악**하고, **효율적이고 안전한 SW를 개발**하는 데 매우 중요함
