## 박상윤

## 패리티 비트

### 패리티 비트(Parity Bit)란?

- 송수신되는 데이터의 오류를 검출하기 위해서 사용되는 일종의 **오류 식별자**
- 정보의 전달 과정에서 오류가 생겼는지를 검사하기 위해 **추가된 비트**
    
    ![image](https://github.com/user-attachments/assets/c9267391-42ff-4c91-8655-1290843f32e5)


---

### 짝수 패리티(Even Parity)와 홀수 패리티(Odd Parity)란?

![image 1](https://github.com/user-attachments/assets/95fa6b06-7d6a-4b1e-8495-943e73343447)

- **짝수 패리티**
    - 전체 ‘1’의 개수가 **짝수**가 되도록 패리티 비트를 설정하는 것
    - 예를 들어, 데이터 비트에 ‘1’이 홀수 개라면 패리티 비트는 1, 짝수 개라면 0
- **홀수 패리티**
    - 전체 ‘1’의 개수가 **홀수**가 되도록 패리티 비트를 설정하는 것
    - 예를 들어, 데이터 비트에 ‘1’이 짝수 개라면 패리티 비트는 1, 홀수 개라면 0

---

### 패리티 비트가 중요한 이유(굳이 왜 필요해?)

- 데이터를 송수신하는 과정에서 **각 비트를 단위시간당 하나씩** 보내게 되어있음
- 이때 **알 수 없는 요인에 의해서 비트의 값이 틀어져 1이 0로, 0이 1로 바뀌었을 때** 이를 확인할 수 있도록 하기 위함
- 패리티 비트를 정하여 데이터를 보내면 받는 쪽에서는 **수신된 데이터의 전체 비트를 계산하여 패리티 비트를 다시 계산함**으로써 데이터 오류 발생 여부를 알 수 있음

---

### 오류 검출의 한계

- 패리티 비트는 오류를 “**검출**”만 할 뿐, 어떤 비트가 오류인지를 “**파악**”하거나 “**수정**”하는 기능은 없음
- 2개 이상의 비트가 동시에 잘못 변경되는 경우, 패리티 비트로는 오류를 정확히 감지하지 못할 수 있음

---

### 활용 예시

- **통신 시스템**
    - 네트워크나 시리얼 통신 등에서 데이터 전송 중 간단한 오류 검출 용도로 사용
- **메모리 시스템**
    - 일부 컴퓨터 메모리 시스템에서는 메모리 내 데이터의 무결성을 확인하기 위해 패리티 검사를 사용하기도 함

---

### 장점과 단점

- **장점**
    - 구현이 매우 간단하고 추가되는 오버헤드가 매우 작음
    - 단순한 오류 검출에 효과적
- **단점**
    - 복잡한 오류 상황이나 다중 비트 오류는 감지하기 어려움
    - 오류 정정 능력이 없으므로, 추가적인 오류 정정 기법과 함께 사용되는 경우가 많음(단일로는 사용하지 않음)
    

<aside>
❓

**패리티 비트는 무조건 7비트나 8비트에서만 사용할 수 있나요?**

- 패리티 비트는 기본적으로 “데이터 내 1의 개수를 짝수 또는 홀수로 만들자”는 원칙에 기반하기 때문에, 16비트나 32비트 같은 데이터에도 사용 가능한 유연한 기술입니다.
- 다만, 실무에서는 7비트나 8비트를 컴퓨터 시스템이나 통신 프로토콜에서 한 단위(바이트 또는 ASCII 문자)를 다룰 때 많이 사용되기 때문에, 7비트나 8비트 데이터에 패리티 비트를 적용하는 경우가 많습니다.
</aside>

<aside>
❓

**패리티 비트의 위치는 정확히 어디에 붙여야 하나요?**

- 패리티 비트의 위치는 정해진 규칙이 있는 것이 아니라, 사용하는 통신 프로토콜에 따라 달라집니다.
- UART/RS-232와 같은 통신 프로토콜에서는 보통 데이터 비트 뒤에 패리티 비트를 추가하여 전송합니다.
- 하지만, 특정 커스텀 프로토콜의 경우에 데이터 앞쪽에 패리티 비트를 배치할 수도 있습니다.
- 중요한 점은 송신측과 수신측 모두 동일한 위치에 패리티 비트를 두어 오류 검출을 하는데 일관된 규칙을 유지하는 것이 가장 중요합니다.
</aside>

## 해밍 코드

### 해밍 코드란?

- 데이터 비트에 몇 개의 **체크 비트(패리티 비트)**가 추가된 코드
- 기존에 체크 비트들은 수신된 데이터열에 에러가 있다 없다 정도만 확인 할 수 있었는데, 해밍 코드를 이용하면 **수신단은 에러 비트의 위치가지 알 수 있게 할 뿐만 아니라 정정**할 수 있음

> 수학자 **리처드 웨슬리 해밍**(Richard Wesley Hamming)이 1940년대 말에 벨 연구소에서 개발하여 1950년 펴낸 저서에 소개 되어있는데, 그의 이름을 따서 **Hamming Cod**e라고 명명되었다.
> 

---

### 해밍 조건

- 해밍 코드는 어떤 길이의 **데이터어(data word)**에도 사용할 수 있음
- **n개의 데이터어**에 **k개 패리티 비트**를 더하여 **n+k 비트**의 새로운 **코드어(code word)**를 생성함
- 신드롬(syndrome: 오류 검사에 사용되는 유일한 패턴) 값 C는 k개의 비트로 이루어지고 0에서 $2^k-1$사이의 $2^k$개의 범위를 가짐
- 이 값 중 하나(보통 0)는 오류가 없음을 나타내기 위해 사용되고, 나머지 $2^k-1$값은 n+k 비트의 한 곳에서 오류가 있음을 나타냄
- $2^k-1$의 각각의 오류가 있는 비트를 유일하게 나타내는데 사용되므로 k의 범위는 n+k보다 크거나 같음. 여기서 아래 식을 얻을 수 있음

$$
2^k-k-1 >=n
$$

- 예를 들어, k=3이면 데이터 비트 수는 4
- k=4이면 데이터 비트 수는 11 ⇒ 이 경우 데이터 비트는 11 이하 5 이상 ⇒ 데이터 비트가 5 미만이면 3개의 체크 비트만 필요함(k=3, 굳이 k=4일 필요가 없음)
    
    ![image 2](https://github.com/user-attachments/assets/d9511d7c-93ec-4ec4-8e2f-78755187f463)


---

### 패리티 비트의 위치

- 해밍 코드에서는 보통 데이터 비트에 추가되는 패리티 비트를 **전체 비트열 내의 2의 거듭제곱 위치**(1, 2, 4 ,8, …)에 배치
- **예시 - 해밍(7, 4) 코드:**
    - 4개의 데이터 비트와 3개의 패리티 비트 ⇒ 7비트 코드
    - 각 비트의 위치
        - **1번 자리 (p1):** 패리티 비트
        - **2번 자리 (p2):** 패리티 비트
        - **3번 자리 (d1):** 데이터 비트
        - **4번 자리 (p3):** 패리티 비트
        - **5번 자리 (d2):** 데이터 비트
        - **6번 자리 (d3):** 데이터 비트
        - **7번 자리 (d4):** 데이터 비트

---

### 패리티 비트의 계산 방법

- 각 패리티 비트는 **특정 위치의 비트들을 검사**하여 계산
- 예를 들어, 짝수 패리티를 사용하는 경우, 각 패리티 비트는 자신이 담당하는 **비트 그룹 내의 1의 개수가 짝수가 되도록 설정**
- **각 패리티 비트의 검사방법**
    - **p1 (1번 자리):**
        
        p1는 1번 자리부터 시작해, 이진수 표현에서 1번째 비트가 1인 모든 위치(1, 3, 5, 7, …)의 비트를 검사
        
    - **p2 (2번 자리):**
        
        p2는 이진수에서 2번째 자리가 1인 위치(2, 3, 6, 7, …)의 비트를 검사
        
    - **p3 (4번 자리):**
        
        p3는 이진수에서 3번째 자리가 1인 위치(4, 5, 6, 7, …)의 비트를 검사
        
        ![image 3](https://github.com/user-attachments/assets/612701d8-a92f-44e8-a2e8-6c81811656c5)

- 위의 예제는 패리티 4 비트와 데이터 8 비트로 이루어진 코드어 12비트(짝수 패리티)
- **각 패리티 비트가 계산되는 과정** - 모든 패리티 비트는 짝수 패리티 규칙을 지켜야 함
    
    ![image 4](https://github.com/user-attachments/assets/e842311a-a052-4146-8063-29b7e1968726)

- 결론적으로 다음과 같은 합성어가 완성됨
    
    ![image 5](https://github.com/user-attachments/assets/8a962199-88a0-45d4-abfc-c2b25ec194ad)


---

### 해밍 코드의 검증(신드롬 값 계산)

- 위의 예제인 12 비트를 메모리에서 읽어 오류를 검증할 때, 패리티는 **패리티 비트를 포함하는 동일한 비트 조합**을 통해 검사됨
- **각 패리티 비트가 계산되는 과정**
    
    ![image 6](https://github.com/user-attachments/assets/494c3ceb-5642-478e-801b-214ceee8c3cd)

    ![image 7](https://github.com/user-attachments/assets/56424fe4-915d-4f90-92b3-c51d366636b2)

    ![image 8](https://github.com/user-attachments/assets/a68ae437-287a-44f1-8a95-9ff1c8904f83)

- 비트들은 짝수 패리티로 저장되므로 결과 $C=C_8C_4C_2C_1=0000$는 오류가 발생하지 않았음을 나타냄
- 그러나, C가 0이 아닌 경우, 패리티 비트에 의해 형성된 **4비트의 이진수는 에러 비트의 위치를 제공**
- 예제 - 6번 비트 0 → 1로 잘못 송신
    - $C_1 =$  XOR 비트 그룹(1, 3, 5, 7, 9, 11) = $0+1+1+0+1+1=0$ ⇒ 짝수 패리티 충족 → 신드롬 비트 **s1 = 0**
    - $C_2 =$  XOR 비트 그룹(2, 3, 6, 7, 10, 11) = $0+1+1+0+0+1=1$ ⇒ 짝수 패리티 위배 → 신드롬 비트 **s2 = 1**
    - $C_4 =$  XOR 비트 그룹(4, 5, 6, 7, 12) = $0+1+1+0+1+1=0$ ⇒ 짝수 패리티 위배 → 신드롬 비트 **s3 = 1**
    - $C_8 =$  XOR 비트 그룹(8, 9, 10, 11, 12) = $0+1+1+0+1+1=0$ ⇒ 짝수 패리티 충족 → 신드롬 비트 **s4= 0**
- 위에서 구한 신드롬 비트들을 보통 **s4s3s2s1** 순서(가장 높은 자리 → 가장 낮은 자리)로 묶어 2진수로 표현
- 따라서 **$S=s4s3s2s1=0110_2=6$** **(10진수)**이 됨
- **신드롬 값이 0이 아니면** 해당 10진수 값이 “오류가 발생한 비트 위치”임을 의미 ⇒ 즉, 여기서는 **6번 비트**가 오류
- 6번 비트를 **반전(1→0)**하면 짝수 패리티가 모두 만족하므로 원래 코드로 **복원**

---

### 한계 및 확장

- **단일 비트 오류에 한정:**
    - 해밍 코드는 단일 비트 오류를 효과적으로 정정할 수 있지만, 2개 이상의 비트에 오류가 발생하면 정확한 정정은 어려워짐
- **확장:**
    - 이중 오류까지 감지할 수 있도록 추가적인 패리티 비트를 덧붙이는 확장 해밍 코드(예: SECDED, Single Error Correction, Double Error Detection)도 존재
