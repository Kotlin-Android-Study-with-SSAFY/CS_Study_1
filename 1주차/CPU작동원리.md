## 김성민
# CPU

- 주 기억장치인 메모리에서 명령어를 읽어 들이고 이를 해석하여 수행
- CPU는 `연산장치(ALU)` , `제어장치(CU)` , `레지스터` , `캐시 메모리` , `시스템 버스`로 구성

<img width="528" alt="image" src="https://github.com/user-attachments/assets/3ebae83a-85dc-45cb-880b-20017d897310" />

이미지 출처: https://mk28.tistory.com/15

# 연산 장치(ALU, Arithmetic Logic Unit)

- CPU의 핵심 요소로서 다양한 산술 및 논리 연산을 처리
- 레지스터를 통해 입력받은 피연산자와 제어 유닛으로부터 받은 명령에 따라 ALU는 연산을 수행
- 그 결과는 다시 레지스터에 저장되어 필요에 따라 메모리에 전송
- 연산 결과를 플래그 레지스터에 저장함으로써, 추가적인 상태 정보(**플래그**)를 제공
- 플래그는 연산 결과가 양수 또는 음수인지, **오버플로우**(연산 결과가 레지스터의 용량을 초과한 경우)가 발생했는지 등의 정보를 나타냄

## ALU 구성 요소

- **가산기(Adder)**: 덧셈을 수행하는 회로. 뺄셈은 2의 보수를 이용해 덧셈으로 처리
- **논리 연산기(Logic Unit)**: AND, OR, XOR 등의 연산을 담당
- **누산기(Accumulator, AC)**: 연산 결과를 임시 저장하는 레지스터
- **상태 플래그(Status Flags)**: 연산 결과에 따라 오버플로우(Overflow), 캐리(Carry), 제로(Zero) 등의 상태를 기록

## ALU 주요 기능

- 산술 연산
- 논리 연산
- 비교 연산
- 비트 연산

# 제어장치(CU, Control Unit)

- 다양한 하드웨어 구성 요소들을 조율하고 관리하는 역할
- 시스템 전체의 효율적인 작동을 위해 전기적 제어 신호를 발생시키고, 이를 통해 다른 컴퓨터 부품들의 동작을 제어

## 제어장치가 받는 정보

- 제어장치는 클럭 신호를 받아들임
- 제어장치는 레지스터로부터 명령어 레지스터에서 명령어와, 플래그 레지스터에서 플래그를 받아들임
- 시스템 버스, 그중 제어 버스로 전달된 제어 신호를 받아들임

## 제어장치가 주는 정보

- CPU 외부에 위치한 여러 하드웨어 구성 요소들에게 제어 신호를 보냄
- CPU 내부에 위치한 ALU나 레지스터에게 내부 제어 신호를 생성

## 제어장치 구성요소

- **명령어 레지스터(IR, Instruction Register)**
    - 현재 실행 중인 명령어를 저장
- **프로그램 카운터(PC, Program Counter)**
    - 다음 실행할 명령어의 주소를 가르킴
    - CPU는 현재 PC가 가르키는 명령어를 실행하고 PC는 다음 명령어의 위치를 가르킴
- **디코더(Decoder)**
    - 명령어를 해석하여 수행할 작업을 결정
- **제어 신호 발생기(Control Signal Generator)**
    - CPU 내부 부품들이 적절히 동작하도록 신호를 생성

## 제어장치 주요 기능

- **명령어 디코딩**: 메모리에서 가져온 명령어를 해석하여 어떤 작업을 수행할지 결정
- **데이터 흐름 제어**: ALU, 레지스터, 메모리, 입출력 장치 간의 데이터 이동을 조정
- **명령어 실행 순서 관리**: 프로그램 카운터(PC)를 조정하여 명령어가 올바른 순서로 실행되도록 함
- **제어 신호 생성**: CPU 내부와 외부 장치에 필요한 제어 신호를 보냄

# 레지스터 (Register)

- 레지스터는 CPU 내부에 있는 고속 메모리로, 실행 중인 데이터와 명령어를 임시로 저장
- 레지스터는 메모리보다 접근 속도가 훨씬 빠르기 때문에 CPU 성능에 중요한 영향을 미침

## 레지스터 종류

- **프로그램 카운터(PC, Program Counter)**: 현재 실행 중인 명령어의 메모리 주소를 저장
- **명령어 레지스터(IR, Instruction Register)**: 현재 실행할 명령어를 저장
- **메모리 주소 레지스터(MAR, Memory Address Register)**: 메모리의 주소를 저장
- **메모리 버퍼 레지스터(MBR, Memory Buffer Register)**: 메모리와 주고받을 데이터와 명령어를 저장
- **누산기(AC, Accumulator)**: 연산 결과를 임시로 저장
- **범용 레지스터(General Purpose Register)**: 연산을 수행하는 동안 데이터를 임시로 저장
- **스택 포인터(SP, Stack Pointer)**: 스택(Stack)의 최상위 주소를 가리킴
- **플래그 레지스터(Flags Register)**: 연산의 상태(예: 오버플로우 발생 여부, 0인지 여부)를 저장

# CPU 작동 원리

- CPU는 기본적으로 **명령어 사이클**(Instruction Cycle)이라는 과정을 반복하면서 동작
- **명령어 사이클은**  CPU가 프로그램을 실행하는 기본 단위
- **명령어 사이클**은 일반적으로 "Fetch-Decode-Execute" (가져오기-해독-실행) 주기

<img width="151" alt="image" src="https://github.com/user-attachments/assets/c64a22bd-0965-4413-ad16-aaabb12c19fc" />

## Fetch
- CPU는 메모리에서 다음에 실행할 명령어를 가져오는 과정
- PC 값 읽기: 프로그램 카운터(PC)에 저장된 주소를 읽음
- 메모리 접근: 해당 주소에서 명령어를 가져와 명령어 레지스터(IR)에 저장
- PC 증가: 다음 명령어를 실행하기 위해 PC 값을 증가(보통 +1)

## Decode
- CPU가 가져온 명령어를 분석하여 어떤 동작을 수행해야 하는지 결정하는 과정
- 명령어 해석: 명령어 레지스터(IR)에 저장된 명령어를 해독
- 연산 종류 판별: ALU(산술논리연산장치) 또는 메모리 연산인지 확인
- 필요한 데이터 가져오기: 명령어가 레지스터 또는 메모리 접근이 필요한 경우 관련 주소 확인

## Execute
- 해독된 명령어를 실제로 실행하는 단계
- 연산 수행: ALU를 사용해 덧셈, 뺄셈 등의 연산을 수행하거나 데이터 이동 실행
- 결과 저장: 연산 결과를 레지스터 또는 메모리에 저장 -> 이때 결과는 아직 최종 저장되지 않고, CPU 내부 버스나 임시 레지스터에 보관될 수 있음
- 플래그 설정: 연산 결과에 따라 조건 플래그(CPU 상태 레지스터)가 변경될 수 있음

## Write-back 
- 명령어대로 처리 완료된 데이터를 메모리에 기록
- **Write-back** 과정은 모든 명령어에 적용되는건 아니고 일부 명령어에만 적용됨
- 연산 결과 저장: 레지스터 또는 메모리에 결과 기록 -> 연산 결과가 CPU 내부의 특정 레지스터나 메모리에 반영
- PC 업데이트: 다음 명령어 실행을 위해 PC 유지 또는 분기 명령어 수행

## ex) 더하기 명령 실행 과정 `ADD R1, R2, R3 (R1 = R2 + R3)`
- **Fetch**: 명령어 ADD R1, R2, R3 를 메모리에서 IR로 가져옴
- **Decode**: ADD 연산임을 해독하고, R2와 R3의 값을 가져와야 함을 확인
- **Excute**: R2와 R3의 값을 더한 후 R1에 임시적으로 저장 -> 데이터 저장 위치: ALU 내부(임시 저장)
- **Write-back**: 결과를 R1 레지스터에 저장 -> 데이터 저장 위치: R1 레지스터
 
