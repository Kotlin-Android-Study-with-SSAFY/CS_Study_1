# 파일 시스템

## 파일

> **하드 디스크나 SSD와 같은 보조기억장치에 저장된 관련 정보의 집합 
의미 있고 관련 있는 정보를 모은 논리적 단위**
> 
- **파일에는 이름과 파일을 실행하기 위한 정보, 파일 관련 부가 정보가 있다.**
- **파일 관련 부가 정보 : 속성(attribute), 메타데이터(metadata)**
- **아래와 같이 파일 형식, 위치, 크기 등 파일과 관련된 다양한 정보가 나오는데 이러한 정보가 파일 속성이다.**


## **파일 속성과 유형**

- **운영체제마다 유지하는 파일 속성은 조금씩 차이가 있지만, 대표적인 속성의 종류는 다음과 같다.**
- **파일 시스템은 파일별로 다음과 같은 속성을 유지하고 관리한다.**
    
    ![image 1](https://github.com/user-attachments/assets/3ae2e8f7-318f-45e1-a82d-bcf9685d72b4)


- **파일 속성 중 파일 유형은 운영체제가 인식하는 파일 종류를 나타낸다.**
- **같은 이름의 파일일지라도 텍스트 파일, 실행 파일, 음악 파일 등 유형이 다르면 실행 양상도 달라진다.**
- **파일을 실행할 운영체제에 파일 유형을 알려준다.**
- **파일 유형을 알리기 위해 가장 흔히 사용하는 방식은 파일 이름 뒤에 붙는 확장자를 이용하는 것이다.**
    
    ![image 2](https://github.com/user-attachments/assets/c06b6acd-d230-465d-a77a-93691752779f)


## **파일 연산을 위한 시스템 호출**

- **파일을 다루는 모든 작업은 운영체제에 의해 이뤄진다.**
- **어떤 응용 프로그램도 임의로 파일을 조작할 수 없으며 파일을 다루려면 운영체제에 부탁해야 한다.**
- **파일 연산을 위한 시스템 호출 제공**
    - **파일 생성, 파일 삭제 , 파일 열기 , 파일 닫기 , 파일 읽기 , 파일 쓰기**
- **파일 생성하고 데이터 기록하기**
    
    open(), write(), close()
    
    ```c
    #include <fcntl.h>
    #include <unistd.h>
    #include <stdlib.h>
    
    int main() {
        int fd;
        char buffer[128];
    
        // 파일 열기
        fd = open("example.txt", O_RDONLY);
        if (fd == -1) {
            return -1; // 파일 열기 실패
        }
    
        // 데이터 읽기
        if (read(fd, buffer, sizeof(buffer)) == -1) {
            close(fd);
            return -1; // 데이터 읽기 실패
        }
    
        // 읽은 데이터 출력
        write(STDOUT_FILENO, buffer, sizeof(buffer));
    
        // 파일 닫기
        close(fd);
        return 0;
    }
    
    ```
    
    ```java
    import java.io.FileOutputStream;
    import java.io.IOException;
    
    public class Main {
        public static void main(String[] args) {
            String data = "Hello, File System!\n";
    
            // try-with-resources 구문을 사용하여 파일을 자동으로 닫음
            try (FileOutputStream fos = new FileOutputStream("example.txt")) {
                fos.write(data.getBytes());
            } catch (IOException e) {
                // 파일 열기 또는 쓰기 실패 시 처리
                e.printStackTrace();
            }
        }
    }
    ```
    

---

# **디렉터리**

> **파일을 일목요연하게 관리하기 위해 디렉터리를 이용할 수 있다. 
윈도우 운영체제에서는 디렉터리를 폴더(folder)라고 부른다.**
> 

### **1단계 디렉터리(single-level directory)**

> **모든 파일이 하나의 디렉터리 아래에 있었는데, 이와 같은 디렉터리 구조를 1단계 디렉터리라 한다.**
> 
- **옛날 운영체제에서는 하나의 디렉터리만 존재했다.**
- **1단계 디렉터리로는 많은 파일을 관리하기가 어려워 트리 구조 디렉터리가 생겨나게 되었다.**

![image 3](https://github.com/user-attachments/assets/b914efbf-643f-4318-bd47-8c1b2b81c6d6)


### **트리 구조 디렉터리 (tree-structrued directory)**

> **최상위 디렉터리가 있고, 그 아래에 여러 서브 디렉터리(자식 디렉터리)가 있다. 
최상위 디렉터리는 흔히 루트 디렉터리라고 부르고 슬래시(/)로 표현한다.**
> 

![image 4](https://github.com/user-attachments/assets/4691d3a1-1250-4202-8675-be95234041ae)


**[🗒️ 참고] 윈도우 운영체제에서 최상위 디렉터리는 흔히 C:\로 표현한다.** 

---

## **경로**

### **절대 경로**

> **같은 디렉터리에는 동일한 이름의 파일이 존재할 수 있지만, 서로 다른 디렉터리에는 동일한 이름의 파일이 존재할 수 있다. 모든 파일에 루트 디렉터리에서 자기 자신까지 이르는 고유한 경로를 가지고 있고, 이러한 경로를 절대 경로라고 부른다.**
> 
- **유닉스, 리눅스, macOS 등 운영체제에서 슬래시 기호(/)는 루트 디렉터리를 표시할 뿐만 아니라 디렉터리와 디렉터리 사이의 구분자로도 사용한다. (/home/minchul/a.sh)**
- **윈도우에서는 디렉터리 구분자로 \로 사용한다. 즉, 윈도우 운영체제에서 a.sh의 절대 경로는 C:\home\minchul\a.sh로 표현된다.**

### **상대 경로**

> **절대 경로가 루트 디렉터리부터 시작하는 경로라면 상대 경로는 현재 디렉터리부터 시작하는 경로이다.**
> 

### **디렉터리를 연산을 위한 시스템 호출**

> **운영체제가 파일 연산을 위한 시스템 호출을 제공하는 것처럼 운영체제는 디렉터리 연산을 위한 시스템 호출도 제공한다.**
> 
- **디렉터리 생성, 디렉터리 삭제, 디렉터리 열기, 디렉터리 닫기, 디렉터리 읽기**

---

## 마운트

> **유닉스, 리눅스 등의 운영체제에서 ‘저장 장치를 마운트한다’라는 표현을 자주 사용한다. 
한 저장 장치의 파일 시스템에서 다른 저장 장치의 파일 시스템에 접근할 수 있도록 파일 시스템을 편입시키는 작업을 말한다.**
> 

![image 5](https://github.com/user-attachments/assets/69ae63f6-c04e-42f0-ad86-b751b1227e12)


**위의 디렉터리 구조를 가진 컴퓨터** 

![image 6](https://github.com/user-attachments/assets/017bb1fa-ec23-4150-91a7-2804cf1e4e9f)


**위의 디렉터리 구조를 가진 USB 메모리**

- **USB 메모리의 파일 시스템을 컴퓨터의 /mnt 경로에 마운트하면 /mnt 경로에 USB 메모리의 파일 시스템이 다음 그림과 같이 연결된다.**
- **/mnt/homework/os/a.cpp 경로를 통해 a.cpp 파일에 접근할 수 있다.**
    
    ![image 7](https://github.com/user-attachments/assets/2632bde1-9b9b-49b4-8af1-19a0d77dc27d)

    

<aside>

**유닉스, 리눅스와 같은 운영체제에서 다양한 저장 장치를 컴퓨터에 연결할 때 mount 명령어로 빈번하게 마운트한다.** 

</aside>

---

## 디렉터리 엔트리

> **파일이 내부에 해당 파일과 관련된 정보를 담고 있다면, 디렉터리는 내부에 해당 디렉터리에 담겨있는 대상과 관련된 정보를 담고 있다. 이 정보는 보통 테이블(표) 형태로 구성된다.**
> 
- **디렉터리는 보조기억장치에 테이블 형태의 정보로 저장된다.**
- **각각의 엔트리(행)에 담기는 정보는 파일 시스템마다 차이가 있다.**
- **디렉터리 엔트리가 공통으로 포함하는 정보가 있다면 그것은 디렉터리에 포함된 대상의 이름과 그 대상이 보조기억 장치 내에 저장된 위치를 유추할 수 있는 정보가 담긴다.**

![image 8](https://github.com/user-attachments/assets/a3a515d8-736f-4f99-beaa-b058aae3b504)


- **보조기억장치 내의 파일/디렉터리 위치를 나타내는 방법에는 시스템마다 차이가 있다.**

<aside>

**즉, 디렉터리 엔트리만 보아도 해당 디렉터리에 무엇이 담겨 있는지, 그리고 그것들은 보조기억장치의 어디에 있는지를 직간접적으로 알 수 있다.** 

</aside>

![image 11](https://github.com/user-attachments/assets/c5afe339-54e4-4ce2-81a6-258d9defeb4f)


- **home 디렉터리 구성, ..은 상위 디렉터리, .은 현재 디렉터리**
- **디렉터리 엔트리를 통해 보조기억장치에 저장된 위치를 알 수 있기 때문에 home 디렉터리에서 minchul 디렉터리가 저장된 곳을 알 수 있고 따라서 그곳으로 이동할 수 있다.**

<aside>

**디렉터리 엔트리에는 디렉터리에 속한 파일들의 이름과 이들의 위치를 알 수 있는 정보 등이 포함되어 있기 때문에 이 파일들이 보조기억 장치 내에 저장된 위치를 알 수 있고 실행할 수 있는 것이다.** 

</aside>

---

# 파일 시스템

> **파일과 디렉터리를 보조 기억장치(하드 디스크, SSD, USB 등)에 저장하고 접근할 수 있게 하는 운영체제 내부 프로그램 
운영체제는 파일 시스템을 통해 사용자가 파일과 폴더(디렉토리)를 생성, 수정, 삭제할 수 있또록 하며, 데이터를 효율적으로 찾고 접근할 수 있게 도와준다.**
> 
- **파일 시스템에는 다양한 종류가 있고, 하나의 컴퓨터에서 여러 파일 시스템을 사용할 수 있다.**

### 주요 기능 및 역할

- **데이터 저장 및 관리**
    
    데이터를 파일 단위로 저장하고, 파일들을 폴더 구조로 조직하여 사용자가 쉽게 관리할 수 있도록 합니다.
    
- **파일 접근 및 검색**
    
    파일의 이름, 위치, 크기, 생성 및 수정 날짜 등의 메타데이터를 관리해 사용자가 원하는 파일을 빠르게 검색하고 접근할 수 있도록 합니다.
    
- **공간 할당 및 관리**
    
    저장 장치의 물리적 공간을 효율적으로 분배하여 파일이 저장될 위치를 지정하고, 남은 공간을 관리합니다.
    
- **보안 및 권한 관리**
    
    파일이나 폴더에 대한 접근 권한을 설정해 데이터 보안을 유지하며, 사용자별로 접근 제어를 가능하게 합니다.
    

### 파일 시스템의 종류

- **FAT (File Allocation Table)**
    
    초기 컴퓨터 시스템과 플로피 디스크, USB 드라이브에서 많이 사용되었습니다.
    
- **NTFS (New Technology File System)**
    
    주로 Windows 운영체제에서 사용되며, 보안 및 대용량 저장에 적합한 기능을 제공합니다.
    
- **ext 시리즈 (예: ext4)**
    
    Linux 기반 시스템에서 널리 사용되는 파일 시스템으로, 높은 안정성과 성능을 자랑합니다.
    
- **APFS (Apple File System)**
    
    Apple의 최신 운영체제에서 사용되는 파일 시스템으로, 최적화된 성능과 보안 기능을 제공합니다.
    

---

## 파**티셔닝과 포매팅**

> **보조기억장치에 곧바로 파일을 생성하거나 저장할 수 없다. 
보조기억장치를 사용하려면 파티셔닝과 포매팅을 거쳐야 한다.**
> 

### 파티셔닝(partitioning)

> **저장 장치의 논리적인 영역을 구획하는 작업**
> 
- **하드 디스크나 SSD처럼 용량이 큰 저장 장치를 하나 이상의 논리적인 단위로 구획하는 것이다.**
- **이렇게 파티셔닝 작업을 통해 나누어진 영역 하나하나를 파티션이라고 한다.**
    
### **포매팅(formatting)**

> **파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하고, 
새로운 데이터를 쓸 준비를 하는 작업**
> 
- **어떤 종류의 파일 시스템을 사용할지는 이때 결정된다.**
- **포매팅의 종류에는 저수준 포매팅과 논리적 포매팅이 있다.**
- **전자는 저장 장치를 생성할 당시 공장에서 수행되는 물리적인 포매팅이고, 후자는 파일 시스템을 생성하는 포매팅이다.**

<aside>

**파일 시스템에는 여러 종류가 있고, 파티션마다 다른 파일 시스템을 설정할 수도 있다. 포매팅까지 완료하여 파일 시스템을 설정했다면 이제 파일과 디렉터리를 생성할 수 있다.** 

</aside>

---

# **파일 할당**

> **운영체제는 파일과 디렉터리르 블록(block)단위로 읽고 쓴다. 
즉, 하나의 파일이 보조기억장치에 저장될 때는 하나 이상의 블록에 걸쳐 저장된다.**
> 
- **하드 디스크의 가장 작은 저장 단위는 섹터이지만, 운영체제는 하나 이상의 섹터를 블록이라는 단위로 묶은 뒤 블록 단위로 파일과 디렉터리를 관리한다.**
- **파일 시스템이 모든 섹터를 관리하기에는 개수가 너무 많고 크기도 작기 때문이다.**

**[예시] 하드 디스크 내에 여러 블록이 있다고 가정**

![image 15](https://github.com/user-attachments/assets/6a17e8da-e96a-441e-b985-65e0fadf2974)


- **블록 안에 적힌 정보는 블록의 위치를 식별하는 주소**
- **이 블록에 우리가 사용하는 파일을 할당해야 한다.**
- **크기가 작은 파일은 적은 수의 블록에 걸쳐 저장되고, 크기가 큰 파일은 여러 블록에 걸쳐 저장된다.**

 ****

---

# 파일을 보조기억장치에 할당하는 방법

![image 16](https://github.com/user-attachments/assets/32102c76-966c-4045-be0e-98862349f236)


- **불연속 할당 : 오늘날까지 사용되는 방식**

## 연속 할당(contiguous allocation)

> **파일이 저장 장치 내에서 연속적인 공간을 차지하도록 블록을 할당하는 방법**
> 
- **보조기억장치 내 연속적인 블록에 파일을 할당하는 방식**
- **블록을 세 개, 두 개, 다섯 개 차지하는 정도의 크기를 가진 파일  a, b, c가 있을 때 이 파일들은 다음과 같이 연속적으로 할당된다.**

![image 17](https://github.com/user-attachments/assets/01ec6f5f-16ce-4536-9266-b699f3709195)


![image 18](https://github.com/user-attachments/assets/671c28ea-c9a4-436b-8a60-85ce2af518bb)

- **연속으로 할당된 파일에 접근하기 위해서는 파일의 첫 번째 블록 주소와 블록 단위의 길이만 알면 된다.**
- **연속 할당을 사용하는 파일 시스템에서는 디렉터리 엔트리에 파일 이름과 더불어 첫 번째 블록 주소와 블록 단위의 길이를 명시한다.**
- **연속으로 저장하기 때문에 구현이 단순하지만, 외부 단편화를 야기한다.**

![image 19](https://github.com/user-attachments/assets/5b0b802f-bc4e-4f11-8d53-11eb6ec87994)


- **파일 D와 F가 삭제되면 다음과 같이 할당할 수 있는 블록은 총 11개가 남지만, 불행히도 크기가 블록 일곱 개 이상을 사용하는 파일은 할당할 수 없다. 이것을 연속 할당에서의 외부 단편화라고 한다.**

## 연결 할당(linked allocation)

> **각 블록 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당하는 방식**
> 
- **파일을 이루는 데이터를 연결 리스트로 관리**
- **불연속 할당의 일종이기에 파일이 여러 블록에 흩어져 저장되어도 무방하다.**

![image 20](https://github.com/user-attachments/assets/96d79b20-51c5-4f31-96dc-9708a2ba2fd0)


![image 21](https://github.com/user-attachments/assets/f9b8395f-2396-41cc-a80e-b42936d29e0b)


- **마지막 블록(2번 블록)에는 다음 블록이 없다는 특별한 표시자를 기록한다. (-1)**
- **연결 할당을 사용하는 파일 시스템에서는 디렉터리 엔트리에 연속 할당과 마찬가지로 파일 이름과 함께 첫 번째 블록 주소와 블록 단위의 길이를 명시한다.**
- **디렉터리 엔트리에 첫번째 블록 주소와 마지막 블록 주소를 기록할 수도 있다.**

- **연결 할당은 외부 단편화 문제를 해결하지만 여전히 단점이 존재한다.**
    1. **반드시 첫 번째 블록부터 하나씩 차례대로 읽어야 한다.** 
        - **파일 내 임의의 위치에 접근하는 속도, 임의 접근 속도가 매우 느리다.**
        - **i번째 블록에 접근하기 위해서는 반드시 첫 번째 블록부터 i번째 블록까지 일일이 순서대로 접근해야 한다 . 성능 면에서 상당히 비효율적**
    2. **하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록은 접근할 수 없다.** 
        - **하나의 블록 안에 파일 데이터와 다음 블록 주소가 모두 포함되어있어, 파일을 이루는 블록에 하나라도 문제가 생기면, 그 블록 이후의 블록에 접근할 수 없다.**
- **따라서, 연결 할당을 변형한 FAT 파일 시스템을 오늘날까지 많이 사용한다.**

## 색인 할당(indexed allocation)

> **파일의 모든 블록 주소를 색인 블록이라는 하나의 블록에 모아 관리하는 방식이다.**
> 
- **색인 할당은 연결 할당과는 달리 파일 내 임의의 위치에 접근하기 쉽다.**
- **색인 블록 안에 파일을 구성하는 데이터 블록 주소가 있으므로 색인 블록만 알면 해당 파일 데이터에 접근할 수 있다.**

![image 22](https://github.com/user-attachments/assets/a47296cb-db6b-47a0-9bcc-14a59e199e85)


![image 23](https://github.com/user-attachments/assets/d264da8e-acc5-4331-85b4-eab57a02754a)


- **파일 a의 색인 블록은 4번 블록이고, 파일 a의 데이터는 7번, 13번, 11번 블록에 저장되어 있다.**
- **4번 블록 안에는 파일 a를 구성하는 블록들의 주소인 7, 13, 11이 적혀있다.**
- **파일 a에 순차적으로 접근하고 싶다면 색인 블록에 저장된 주소에 차례대로 접근하면 된다.**
- **파일의 i번째 데이터 블록에 접근하고 싶다면 색인 블록의 i번째 항목이 가리키는 블록에 접근하면 되기 때문이다.**
- **색인 할당을 사용하는 파일 시스템에서는 디렉터리 엔트리에 파일 이름과 더불어 색인 블록 주소를 명시한다.**
- **색인 할당을 기반으로 만든 파일 시스템이 유닉스 파일 시스템이다.**

---

# 파일 시스템

> **다양한 파일 시스템이 있지만, 크게 두 가지로 나눌 수 있다. 
하나는 USB 메모리, SD 카드 등의 저용량 저장 장치에서 사용되는 FAT 파일 시스템이고, 
다른 하나는 유닉스 계열 운영체제에서 사용되는 유닉스 파일 시스템이다.**
> 

## FAT 파일 시스템

> **FAT을 이용하는 파일 시스템
연결 할당의 단점을 보완한 파일 시스템**
> 
- **각 블록에 포함된 다음 블록의 주소들을 한데 모아 테이블 형태로 관리하면 앞서 언급한 단점들을 상당 부분 해소 할 수 있다. 이러한 테이블을 파일 할당 테이블(File Allocation Table)이라고 부른다.**

![image 24](https://github.com/user-attachments/assets/35cdf678-1730-4437-8b90-ae5d83d6aa7e)


![image 25](https://github.com/user-attachments/assets/2a80ebc6-231a-4343-a6ac-cfec92b5d0a2)


- **파일의 첫번째 블록 주소(4번 블록)만 알면 파일의 데이터가 담긴 모든 블록에 접근할 수 있다.**
- **디렉터리 엔트리에는 파일 이름과 더불어 파일의 첫 번째 블록 주소가 명시된다.**
- **빈 공간은 아직 할당되지 않은 것이다.**
- **FAT 파일 시스템은 버전에 따라 FAT12, FAT16, FAT32가 있으며, FAT 뒤에 오는 숫자는 블록을 표현하는 비트 수를 의미한다.**
- **FAT 파일 시스템은  단순성과 높은 호환성 덕분에 여전히 USB 드라이브, SD 카드 등 이동식 저장장치에서 널리 사용되고 있다.**
- **하지만 대용량 파일 및 볼륨 관리, 보안 측면에서는 NTFS나 ext 계열 파일 시스템에 비해 한계가 있기 때문에, 사용 목적에 따라 적절한 파일 시스템을 선택하는 것이 중요하다.**

**[🗒️ 참고] 윈도우에서는 ‘블록’이라는 용어 대신 클러스터라는 용어를 사용한다.** 

### 📎 FAT12 파일 시스템을 사용하는 파티션을 간략화한 도식도

![image 26](https://github.com/user-attachments/assets/a72458fa-4cab-4a25-9b64-abd03029de55)

- **FAT 파일 시스템에서는 FAT은 파티션의 앞 부분에 만들어진다.**
- **하드 디스크의 한 파티션을 FAT 파일 시스템으로 포맷하면 해당 파티션이 위와 같이 구성된다.**
- **FAT은 하드 디스크 파티션의 시작 부분에 있지만, 실행하는 도중 FAT가 메모리에 캐시될 수 있다.**
- **메모리 캐시**
    - **운영체제는 FAT를 RAM에 저장해두어, 파일 접근 시 디스크에 직접 접근하지 않고 빠르게 메모리에서 FAT 정보를 조회할 수 있다.**
    - **파일 할당 정보를 얻는 속도가 빨라지고, 전체 파일 시스템 성능이 향상된다.**
    - **FAT가 디스크에 존재하지만, 실제 운영 과정에서 효율적인 처리를 위해 메모리 내에서 사용된다.**
- **FAT가 메모리에 적재된 채 실행되면 기존 연결 할당보다 다음 블록을 찾는 속도가 매우 빨라지고, 임의 접근에도 유리해진다. 즉, FAT가 메모리에 적재된 채 실행되면 임의 접근의 성능이 개선된다**.
- **파일의 데이터 블록 주소들이 하나의 색인 블록(또는 테이블)에 모두 저장되어 있다.**
- **이 색인 블록은 운영체제에 의해 메모리에 캐시되기 때문에, 파일 내 임의의 위치에 접근할 때 필요한 데이터 블록 주소를 디스크에서 직접 읽지 않고 메모리에서 빠르게 조회할 수 있다.**

<aside>

**FAT 자체가 연결 할당의 한 형태이긴 하지만, 메모리 캐시를 통한 빠른 색인 조회 덕분에 실제 운영에서는 연결 할당 방식보다 더 효율적으로 동작할 수 있다.** 

</aside>

### 📎 FAT 파일 시스템의 디렉터리 엔트리

![image 27](https://github.com/user-attachments/assets/058e031e-09f4-4e0f-9379-b4b2296d938d)


- **파일 이름과 더블어 파일의 첫 번째 블록 주소가 명시된다.**
- **이외에도 파일 속성과 더불어 다양한 정보들이 있다.**
- **FAT 파일 시스템에서의 디렉터리는 다음과 같은 형식으로 블록에 저장된다고 보면 된다.**
- **속성 항목은 해당 파일이 읽기 전용 파일인지, 숨김 파일인지, 시스템 파일인지, 일반 파일인지, 디렉터리인지 등을 식별하기 위한 항목이다.**

### FAT 파일 시스템에서 /home/minchul/a.sh 파일을 읽는 과정

![image 28](https://github.com/user-attachments/assets/82b48b46-80fe-47b3-aa1b-3539be5e8712)


![image 29](https://github.com/user-attachments/assets/a127fc53-031b-4fbc-9bc3-1b17e2781c07)


1. **루트 디렉터리 영역에 home 디렉터리는 몇 번 블록에 있는지 확인한다.  ⇒ 3번 블록** 

![image 30](https://github.com/user-attachments/assets/bc2d8509-c27a-4daf-9216-2737eef98014)


2. **minchul 디렉터리가 몇 번 블록에 있는지 확인한다. ⇒ 15번 블록**

![image 31](https://github.com/user-attachments/assets/7e1f8358-720b-410e-9747-3ce9866570bc)


3. [**a.sh](http://a.sh) 파일의 첫번 째 블록 주소가 몇 번 블록에 있는지 확인한다. ⇒ 9번 블록** 

![image 32](https://github.com/user-attachments/assets/30268ef7-cc60-4238-ba69-7894347c97ed)


4. **FAT를 보면 [a.sh](http://a.sh) 파일은 9, 8, 11, 13 순서로 저장된 것을 알 수 있다.** 
    
    **따라서 파일 시스템은 /home/minchul/a.sh을 읽기 위해 9, 8, 11, 13번 블록에 접근한다.** 
    

![image 33](https://github.com/user-attachments/assets/d18293f1-a5ee-4633-995b-9280896936cd)


---

## 유닉스 파일 시스템(Unix File System, UFS)

> **색인 할당 기반의 유닉스 파일 시스템
유닉스 파일 시스템에서 색인 블록을 i-node(index-node)라고 부른다.**
> 
- i**-node에는 파일 속성 정보와 열다섯 개의 블록 주소가 저장될 수 있다.**
- **FAT 파일 시스템에서는 파일 속성 정보가 디렉터리 엔트리에 표현되었지만, 유닉스 파일 시스템에서 파일 속성 정보는 i-node에 표현된다.**

![image 34](https://github.com/user-attachments/assets/56a06de5-0293-48a4-9919-2a8f4e880f9d)


- **유닉스 파일 시스템에는 파일마다 이러한 i-node가 있고, i-node마다 번호가 부여되어 있다.**
- **i-node들은 다음과 같이 파티션 내 특정 영역에 모여 있다.**
- **i-node 영역에 i-node들이 있고, 데이터 영역에 디렉터리와 파일들이 있다.**

![image 35](https://github.com/user-attachments/assets/72f09967-6821-4293-ba75-8c2334cbbc8e)


- **i-node 크기는 유한하다. i-node 하나는 기본적으로  열 다섯 개의 블록 주소를 저장할 수 있다.**
- **블록을 20개, 30개, 그 이상 차지하는 큰 파일의 경우 i-node 하나로 파일의 데이터 블록을 가리킬 수 없다.**

![image 36](https://github.com/user-attachments/assets/d3d28952-7e42-44cd-9349-4345b87ea9ce)


### 어떻게 해결할까?

- **블록 주소 중 열두 개에는 직접 블록 주소를 저장한다.**
    - **파일 데이터가 저장된 블록을 직접 블록이라고 한다.**
    - **이것만으로 파일 데이터 블록을 모두 가리킬 수 있다면 추가적인 작업이 필요하지 않다.**
- **첫번째 방법으로 충분하지 않다면 열세 번째 주소에 단일 간접 블록 주소를 저장한다.**
    - **열두 개의 블록 주소로 파일의 모든 블록을 가리킬 수 없다면 i-node의 열세 번째 블록 주소를 이용한다 .**
    - **열세 번째 블록 주소는 단일 간접 블록의 주소를 저장한다.**
    - **단일 간접 블록 : 파일 데이터가 저장된 블록이 아닌 파일 데이터를 저장한 블록 주소가 저장된 블록**

![image 37](https://github.com/user-attachments/assets/02ee6e20-7b10-4a46-9edd-8bfa397f12f5)


- **두번째 방법으로도 충분하지 않다면 열네 번째 주소에 이중 간접 블록 주소를 저장한다.**
    - **열세 개의 블록 주소로 파일의 모든 블록을 가리킬 수 없다면 i-node의 열네 번째 블록 주소를 이용한다 .**
    - **열네 번째 블록 주소는 이중 간접 블록 주소를 저장한다.**
    - **이중 간접 블록 : 데이터 블록 주소를 저장하는 블록 주소가 저장된 블록**
    - **단일 간접 블록들의 주소를 저장하는 블록**

![image 38](https://github.com/user-attachments/assets/4123b356-e126-4abc-b1bc-79196a2a3dd2)


- **세번째 방법으로 충분하지 않다면 열다섯 번째 주소에 삼중 간접 블록 주소를 저장한다.**
    - **열네 개의 블록 주소로 파일의 모든 블록을 가리킬 수 없다면 i-node의 열다섯 번째 블록 주소를 이용한다 .**
    - **열다섯 번째 블록 주소는 삼중 간접 블록 주소를 저장한다.**
    - **삼중 간접 블록 : 이중 간접 블록 주소가 저장된 블록**
    - **삼중 간접 블록까지 이용하면 웬만한 크기의 파일은 모두 표현할 수 있다.**

![image 39](https://github.com/user-attachments/assets/f5e9286d-dfb1-4ec0-8b25-047afe5985c8)


- **따라서, i-node만 알면 파일 속성뿐만 아니라 파일 크기가 크더라도 파일 데이터를 모두 가리킬 수 있다.**
- **그래서 유닉스 파일 시스템의 디렉터리 엔트리도 파일 이름과 i-node번호로 구성된다.**

![image 40](https://github.com/user-attachments/assets/1bda6031-136e-4cfc-84bf-8f68496654e1)


### 유닉스 파일 시스템에서 /home/minchul/a.sh 파일을 읽는 과정

![image 41](https://github.com/user-attachments/assets/0d0c7882-eede-4865-8ac7-b9ec848e8ea8)


![image 42](https://github.com/user-attachments/assets/5881ae07-e119-4fb2-9beb-af66d5752226)


- **파티션 내에 위와 같이 저장, 각 i-node에는 파일 속성은 제외하고 블록 주소만을 명시했다.**
- **유닉스 파일 시스템은 루트 디렉터리의 i-node를 항상 기억하고 있다.**
1. **2번 i-node에 접근하여 루트 디렉터리의 위치를 파악한다. 루트 디렉터리는 1번 블록에 있다.** 

![image 43](https://github.com/user-attachments/assets/c5fd7bb9-bade-4742-82e0-27a22b111d70)


2. **1번 블록을 읽으면 루트 디렉터리의 내용을 알 수 있다. home디렉터리의 i-node = 3번 i-node**

![image 44](https://github.com/user-attachments/assets/74be7c8d-9492-4acb-9a25-f0b2f91a3aae)


3. **3번 i-node에 접근하여 home 디렉터리 위치를 파악한다. home 디렉터리는 210번 블록에 있다.** 

![image 45](https://github.com/user-attachments/assets/ddabedc1-81f5-4a77-984f-cb54d65d672e)


4. **210번 블록을 읽으면 home 디렉터리 내용을 알 수 있다. minchul 디렉터리의 i-node는 8번**

![image 46](https://github.com/user-attachments/assets/def8c548-ad89-4d03-9e88-4a1789360f6c)


5. **8번 i-node에 접근하여 minchul 디렉터리 위치 파악, 121번 블록**

![image 47](https://github.com/user-attachments/assets/1647575f-49b9-49db-ac98-196950882f53)


6. **121번 블록을 읽으면 minchul 디렉터리 내용을 알 수 있다. 파일 [a.sh](http://a.sh)의 i-node 9번**

![image 48](https://github.com/user-attachments/assets/095ddcf6-bf99-4db6-9cb8-97e12613a777)


7. **a.sh파일은 98, 12, 13번 블록에 있다 .**

![image 49](https://github.com/user-attachments/assets/9a0bdd6b-09bb-4a11-b154-14adf12dcab8)

---

## 저널링 파일 시스템

> **컴퓨터를 이용해 작업을 하던 도중 갑자기 전원이 나가거나 치명적인 오류로 인해 컴퓨터가 강제로 종료되어 버린 상황 (시스템 크래시)이 발생하면 파일 시스템이 훼손될 수 있다.**
> 
- **저널링 파일 시스템이 있기 전 부팅 직후 파일 시스템을 검사하고 복구하는 프로그램을 실행시킨다.**
    
    **ex) 유닉스나 리눅스의 fsck나 윈도우의 scandisk**
    
- **파일 시스템 내의 모든 블록에 대해 파일 시스템을 검사하기 때문에 시간이 매우 오래 걸린다.**
- **그래서 저널링 기법을 이용한 저널링 파일 시스템이 등장하였다.**

### 저널링 기법?

> **작업 로그를 통해 시스템 크래시가 발생했을 때 빠르게 복구하기 위한 방법**
> 
- **저널링 기법을 사용하는 파일 시스템에서 파일 시스템을 변경하는 작업**
    1. **작업 직전 파티션의 로그 영역에 수행하는 작업(변경 사항)에 대한 로그를 남긴다.** 
    2. **로그를 남긴 후 작업을 수행한다.** 
    3. **작업이 끝났다면 로그를 삭제한다.** 
- **시스템 크래시가 발생하여 다시 부팅을 해야할 경우 파일 시스템 전체를 검사할 필요 없이 로그 영역에 남긴 로그만 검사하면 된다.**
- **마이크로소프트의 NT 파일 시스템, 리눅스의 ext3, ext4 파일 시스템을 포함하여 현대 대부분의 파일 시스템은 저널링 기능을 지원한다.**

<aside>

**저널링 파일 시스템은 시스템 크래시가 발생한 직후에 로그 영역을 읽어 크래시가 발생한 당시 어떠 ㄴ작업을 실행 중이었는지 알아낸 다음 해당 작업을 완료한다.** 

</aside>

---

## NT 파일 시스템(NTFS)

> **NTFS(뉴 테크놀로지 파일 시스템)는 마이크로소프트에서 개발한 파일 시스템으로, 주로 Windows 운영체제에서 사용된다.  NTFS는 높은 안정성, 보안 기능, 확장성을 제공하기 위해 설계되었으며, 여러 가지 중요한 특징을 가지고 있다.**
> 
- **Master File Table (MFT)**: 파일과 디렉터리의 모든 메타데이터(이름, 크기, 위치, 보안 정보 등)를 중앙 테이블에 저장하여 빠른 검색과 관리가 가능합니다.
- **저널링**: 변경 사항을 먼저 기록해 두어, 시스템 장애 시 데이터 복구가 용이합니다.
- **세밀한 보안 관리**: ACL(Access Control List)을 통해 사용자별 접근 권한을 세밀하게 제어할 수 있습니다.
- **부가 기능**: 파일 압축, 암호화, Alternate Data Streams(파일 내 여러 데이터 스트림) 지원 등 다양한 기능 제공.

---

## ext 계열 파일 시스템 (ext2, ext3, ext4)

> Linux 환경에서 주로 사용되는 파일 시스템으로, ext2에서 시작하여 ext3, ext4로 발전해 왔다. 
NTFS와 마찬가지로 데이터 무결성, 보안, 확장성 등 현대 운영체제에서 요구되는 기능들을 제공하지만, Linux에 최적화된 구조와 기능들이 특징이다.
> 
- **inode 기반 구조**: 각 파일은 inode에 저장된 메타데이터(파일 크기, 권한, 데이터 블록 위치 등)를 통해 관리되며, 디렉터리는 파일 이름과 inode 번호의 매핑 정보를 가집니다.
- **저널링**: ext3와 ext4는 저널링 기능을 도입해 데이터 무결성을 높였습니다.
- **ext4의 확장성**: ext4는 Extent(연속된 블록 단위 관리)를 도입해 대용량 파일 및 볼륨 지원, 지연 할당 등으로 성능과 효율성을 크게 개선했습니다.

---

## FAT, NTFS, EXT, UFS 파일 시스템의 주요 특징과 차이

| **파일 시스템** | **사용 OS/환경** | **구조 및 특징** | **저널링 지원** | **보안 및 부가 기능** |
| --- | --- | --- | --- | --- |
| **FAT** | **MS-DOS, 초기 Windows, USB/SD 등** | **부트 섹터, FAT 영역, 데이터 영역으로 구성되며 FAT12, FAT16, FAT32, exFAT 등 버전이 있음. 단순한 구조로 구현 및 이해가 쉬움** | **없음** | **기본적인 보안 기능만 제공하며 파일 크기 및 볼륨에 제한이 있음** |
| **NTFS** | **Windows (NT 계열 이후)** | **Master File Table(MFT) 기반으로 파일/디렉터리의 메타데이터를 중앙에서 관리하며, 클러스터 체인 방식으로 파일 데이터를 연결** | **있음** | **ACL 기반의 세밀한 보안 제어, 파일 압축, 암호화, Alternate Data Streams 지원** |
| **EXT** | **Linux** | **inode 기반의 구조로 디렉터리 엔트리와 inode, 블록 그룹을 이용해 파일을 관리. ext2는 기본 구조, ext3/4는 저널링(및 ext4는 Extent, 지연 할당 등 추가 최적화) 지원** | **ext3/4: 있음ext2: 없음** | **전통 UNIX 권한 체계, 선택적 ACL 지원, 대용량 파일/볼륨 및 성능 최적화** |
| **UFS** | **Unix/BSD 계열 (예: FreeBSD, OpenBSD 등)** | **inode와 블록 그룹 구조를 사용하는 전통적 계층적 파일 시스템. 현대 버전에서는 소프트 업데이트 등으로 성능과 무결성 개선** | **일부 구현에서 있음** | **전통적인 UNIX 권한 체계 적용, 간단하고 안정적인 구조** |

### **요약**

- **FAT: 단순하고 호환성이 높으나, 파일 크기/볼륨 제한, 조각화, 보안 기능 미흡 등의 한계가 있다.**
- **NTFS: Windows 전용으로 고급 메타데이터 관리(MFT), 저널링, ACL 기반 보안, 다양한 부가기능을 통해 FAT의 한계를 극복하였다.**
- **EXT: Linux 환경에 최적화된 inode 기반 파일 시스템으로, ext3/4는 저널링 및 성능 개선 기능(Extent, 지연 할당 등)을 제공하여 안정성과 확장성이 강화되었다.**
- **UFS: 전통적인 Unix 파일 시스템으로, 간단하면서도 안정적인 구조를 가지며 BSD 등 Unix 계열에서 사용된다.**
