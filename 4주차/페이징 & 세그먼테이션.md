## 김성민 Part

# 연속 메모리 할당

- 프로세스가 연속된 메모리 공간에 배치되는 방식

## 고정 분할 방식

- 메모리를 미리 정해진 크기의 고정된 영역(Partition)으로 나누는 방식
- 각 프로세스는 **하나의 파티션에만 배치**될 수 있음
- 큰 파티션이 많으면 작은 프로세스가 들어와도 공간 낭비 발생 → 내부 단편화
- 작은 파티션이 많으면 큰 프로세스를 배치할 수 없음 → 외부 단편화

![image](https://github.com/user-attachments/assets/042c9757-1828-4033-afbd-c4af5a6813c6)

## 가변 분할 방식

- **프로세스가 요청한 크기만큼 동적으로 메모리를 할당하는 방식**
- 내부 단편화 없음
- 프로세스가 종료되면 중간중간 빈 공간(조각난 메모리)이 생김 → 외부 단편
- 압축(Compaction)이 필요할 수도 있음 → 성능 오버헤드 유발

![image](https://github.com/user-attachments/assets/c298e383-d574-4a4c-8e0c-7c69c9ee93cd)

# 페이징

- 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하는 것
- 페이징(Paging)은 프로세스의 논리 주소 공간을 일정한 크기의 페이지(Page) 단위로 나누고
- 물리 메모리도 같은 크기의 프레임(Frame)으로 나눈 뒤
- 페이지를 프레임에 매핑하는 가상 메모리 관리 기법
- **페이지(Page)**: 프로세스를 일정 크기로 나눈 블록 (논리적 단위)
- **프레임(Frame)**: 물리적 메모리를 같은 크기로 나눈 블록 (물리적 단위)
- 페이지(Page)와 프레임(Frame)의 크기는 항상 동일
- 비연속적으로 할당 가능
- 외부 단편화 문제 해결

## 페이지 테이블

- 논리 주소를 물리 주소로 변환
- 각 프로세스는 페이지 테이블을 가지고 있으며 각 페이지가 어느 프레임에 저장되었는지를 기록

## 페이징 과정

1. 프로세스가 메모리 공간을 요청하면 운영체제가 해당 프로세스를 페이지 단위로 나눔
2. 물리 메모리에서 빈 프레임을 찾아 배치
3. 페이지 테이블을 이용해 논리 주소 → 물리 주소 변환

![image](https://github.com/user-attachments/assets/81b1a2fe-5571-41ed-8cee-d7b9db9f3cc9)

## 페이징 장점

- 메모리 공간을 고정된 크기의 페이지로 나누어 페이지 크기만큼 일정하게 할당되므로 연속적인 공간을 필요로 하지 않기 때문에 외부단편화가 발생하지 않는다
- 각 페이지에 독립적인 권한 설정으로 잘못된 접근을 방지하여 메모리 보호

## 페이징 내부 단편화 문제점

1. 프로세스를 페이지 단위로 나눌 때 마지막 페이지의 크기가 프레임보다 작을 경우
2. 페이지는 고정된 크기 이므로 마지막 페이지의 남은 공간을 다른 용도로 사용할 수 없음
3. 즉 마지막 페이지에 낭비되는 공간이 내부 단편화
    - 페이지 크기가 클수록 내부 단편화가 증가할 가능성이 높음
    - 하지만 페이지 크기를 너무 작게 하면 페이지 테이블이 커지는 문제가 발생

ex)

- **페이지 크기 = 4KB**
- **프로세스 크기 = 10KB**
- 10KB를 4KB 단위로 나누면:
    - **Page 0 (4KB)**
    - **Page 1 (4KB)**
    - **Page 2 (2KB) ←** **마지막 페이지에서 2KB 낭비 발생**
- **마지막 페이지에서 사용되지 않은 2KB 공간이 내부 단편화**

# 세그멘테이션

- 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치하는 것
- 논리적인 메모리를 서로 크기가 다른 세그먼트로 분할하여 사용하는 메모리 관리 기법

## 세그먼트

- 논리적인 단위로서 예시로 프로그램의 코드, 데이터, 스택 등을 나타낼 수 있다.
- 세그먼트는 크기가 가변적이다. 각 세그먼트는 크기가 고정되지 않고 프로세스의 요구를 따르기 때문에 세그먼테이션은 동적 할당을 지원한다.
- 세그먼트는 물리적 메모리에서 연속적인 공간에 배치될 필요가 없다 → 세그먼트들은 메모리의 다양한 위치에 불연속적으로 배치된다.

## 세그먼트 테이블

- 세그먼트 번호와 해당 세그먼트에 대응되는 물리 주소와 세그먼트의 크기(한계 주소)를 매핑하는 테이블
- 각 프로세스마다 세그먼트 테이블을 가지고 있음

## 세그먼테이션 과정

![image](https://github.com/user-attachments/assets/e1f16928-fd4c-4b2c-bbe0-0a079cde4cad)

- 프로세스를 여러개의 세그먼트로 나눈다.
- 세그먼트 테이블을 통해 세그먼트 위치를 관리한다
    - 각 세그먼트에는 시작 주소와 세그먼트 크기가 포함됨
    - 세그먼트 테이블을 참조하여 세그먼트의 물리적 주소 확인
- 프로세스가 참조하는 주소는 세그먼트 번호 + 오프셋(세그먼트 내의 특정 데이터나 명령어의 위치)

## 세그먼테이션 장점

- 프로그램의 논리적 구조에 맞게 메모리를 나누어 논리적 메모리 관리를 한다.
- 각 세그먼트는 독립적인 제어가 가능해 효율적으로 메모리를 보호할 수 있다.
- 세그먼트는 동적으로 크기를 조정할 수 있다.
- 세그먼트별로 메모리를 관리하기 때문에 할당과 해제가 좀 더 명확하다.
- 세그먼테이션은 논리적으로 나누기 때문에 보호와 공유에 있어서 페이징 보다 효율적이다.
- 내부 단편화 제거

## 세그먼테이션 단점

- 물리 메모리의 다양한 위치에 다양한 크기의 세그먼트가 분산되어 저장되기 때문에 연속적인 공간이 부족해 질 수 있다. → 외부 단편화

![image](https://github.com/user-attachments/assets/a8b02218-ae46-4bf0-b4e2-e68c0f854c29)

## 페이징 세그먼테이션(Paged Segmentation)

- 세그먼테이션은 보호와 공유에서 효율적이고 페이징은 외부 단편화 문제를 해결 할 수 있는데 이 두 장점을 살리기 위한 방법
- 프로세스 주소 공간을 세그먼트 단위로 나눈 후 각 세그먼트는 페이징 기법을 적용하여 페이지로 분할됨
- 각 세그먼트는 세그먼트 테이블을 통해 관리되며 각 세그먼트 내에서 페이지 테이블을 통해 주소 변환이 이루어짐
- 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두번 해야 한다.
    - CPU에서 세그머트 테이블에서 주소 변환
    - 페이지 테이블에서 또 주소 변환
