# 3 way handshake & 4 way handshake

# TCP(Transmission Control Protocol)

> 서로 다른 종류의 네트워크 장비와 시스템들이 데이터를 주고받을 수 있도록 하는 일련의 규칙과 표준 제공
TCP에서 **3-way handshake**는 클라이언트와 서버 간에 연결을 수립하는 절차이고, **4-way handshake**는 수립된 연결을 종료하는 절차를 의미한다.
> 

---

# 3-Way Handshake(연결 설정)

- TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정
- 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
- TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정

## 3-way handshake의 기본메커니즘

> TCP 통신은 PAR(Positive Acknowledgement with Re-trnasmission) 을 통해 신뢰적인 통신을 제공
> 
- Client는 Server와 연결하기 위해 3-way handshake를 통해 연결 요청을 하게 된다.
- Client와 Server는 모두 서로 연결 요청을 먼저 할 수 있기 때문에, 연결 요청을 먼저 시도한 요청자를 Client(Host P)로, 연결 요청을 받은 수신자를 Server(Host Q)쪽으로 생각하면 된다.

### SYN(Synchronization)

- 연결 요청, 세션을 설정하는데 사용되며 초기에 시퀀스 번호(ISN, Initial Sequence Number)를 보낸다.
- 클라이언트가 연결하고 싶다라고 요청할 때 SYN을 보내고, 서버 또한 자신의 연결 준비 상태를 알릴 때 SYN을 포함해 보낸다.

### ACK(Acknowledgement)

- 보낸 시퀀스 번호에 TCP 계층에서의 길이 또는 양을 더한 것과 같은 값을 ACK에 포함하여 전송
- 상대방이 보낸 메시지를 잘 받았다는 확인 응답으로 사용

**왜 시퀀스 번호에 + 1 을 붙일까❓**

**SYN 패킷은 1 바이트 분량의 시퀀스 번호를 차지하기 때문에, 이를 처리했다고 표시하기 위해 ACK 번호는 원래 시퀀스 번호(데이터가 어떤 순서로 전송되어야 하는지를 나타내는 번호)에 1을 더해서 보내는 것이다.** 

**TCP에서는 이와 비슷하게 각 데이터 조각(패킷)에 번호를 붙여서, 도착한 데이터가 보내진 순서대로 잘 정렬될 수 있도록 도와준다. TCP에서 시퀀스 번호는 TCP가 신뢰성 있고 순서대로 데이터를 전달할 수 있게 하는 중요한 역할을 하게 해주는 도구이다.** 

## 작동 방식

![IMG_1892](https://github.com/user-attachments/assets/735b1ee6-3796-4175-a0cf-042a6e05b1b9)

### **Step 1: CLIENT → SERVER : SYN**

- 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
- **클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다. (seq : x)**

### **Step 2 SERVER → CLIENT : SYN + ACK**

- 접속요청을 받은 Q가 요청을 수락했으며, 접속 요청 프로세스인 P도 포트를 열어달라는 메세지를 전송한다.
- ACK Number필드를 Sequence Number + 1 로 지정하고 SYN과 ACK 플래그 비트를 1로 설정한 새그먼트 전송한다. (Seq=y, Ack=x+1, SYN, ACK)
- **서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보낸다. (seq : y, ACK : x + 1)**

### **Step 3 CLIENT → SERVER : ACK**

- 마지막으로 접속 요청 프로세스 P가 수락 확인을 보내 연결을 맺는다. (ACK)
- 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.
- **클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄**

**이 과정을 통해 양쪽은 서로의 초기 시퀀스 번호를 동기화하고, 안정적인 데이터 전송을 위한 상태 정보를 공유하게 된다. 즉, TCP는 full-duplex 통신을 지원하여, 양쪽에서 동시에 데이터를 전송할 수 있다.**

- **클라이언트가 연결 요청(SYN)을 보냄**
- **서버가 요청을 수용하고 자신의 연결 상태를 알림(SYN-ACK)**
- **클라이언트가 응답(ACK)을 보내며 연결 성립 완료**

---

# 4-Way Handshake(연결 종료)

- 연결을 해제(Connection Termination)하는 과정으로, FIN 플래그를 이용한다.
- FIN(finish) : 세션을 종료시키는데 사용되며, 더 이상 보낸 데이터가 없음을 나타낸다.

### Termination의 종류

> **TCP는  두 가지 연결 해제 방식이 있다**
> 
- **Graceful connection release(정상적인 연결 해제)**
    - 데이터를 모두 전송한 후 상대방과의 상호 확인 절차를 거쳐 안전하게 연결 종료
    - Half-Close 기법 적용해 양방향 통신의 각 채널을 개별적으로 종료
- **Abrupt connection release(갑작스런 연결 해제)**
    - 예외 상황에서 빠른 연결 해제를 위해 사용

## 작동방식(Graceful)

> **Half-Close 기법을 사용하여 양쪽이 독립적으로 데이터 전송을 종료할 수 있도록 한다. 즉, 한쪽에서는 더 이상 데이터를 보내지 않지만, 여전히 상대방이 보내는 데이터를 받을 수 있는 상태이다.**
> 
- **연결 종료 요청 역시, 일반적으로 생각하는 우리가 일반적으로 생각하는 Client와 Server는 모두 서로 연결 요청을 먼저 할 수 있기 때문에, 연결 요청을 먼저 시도한 요청자를 Client로, 연결 요청을 받은 수신자를 Server쪽으로 생각하면 된다.**

## Half-Close 기법❓

- **연결 종료 시 한 쪽만 먼저 종료하되, 상대방은 남은 데이터를 전송할 수 있도록 하는 방식**
- **이 기법에서는 종료 요청자가 처음 전송하는 FIN 패킷에 ACK 정보(승인 번호)가 포함되어, 내 쪽 연결은 종료하지만, 너는 남은 데이터를 전송해도 된다는 의미를 전달**
- **이후 상대방이 남은 데이터를 모두 전송하면, FIN 패킷으로 모든 데이터 전송 완료를 알리며, 요청자는 이 FIN을 확인한 후 나머지 연결을 안전하게 종료**

![IMG_1893](https://github.com/user-attachments/assets/796a9f41-f052-4f37-8636-255451732972)

### **STEP 1: Client → Server : FIN(+ACK)**

- **클라이언트가 더 이상 보낼 데이터가 없을 때, close() 함수를 호출**
- **클라이언트는 서버에게 FIN 플래그가 설정된 패킷을 보내고, 이 패킷에 이전에 받은 데이터를 확인하는 역할의 ACK 정보도 포함되어 있음**
- **클라이언트는 "내쪽은 더 이상 데이터를 보내지 않겠다"는 신호를 보냄**

### **STEP 2: Server → Client : ACK**

- **서버는 클라이언트로부터 도착한 FIN 패킷을 수신**
- **서버는 이를 확인하기 위해 ACK 패킷을 클라이언트에 응답**
- **서버는 클라이언트의 종료 요청을 받아들였으며, 이후 남은 데이터를 모두 처리한 후에 자신의 연결을 종료할 준비**
- **이 시점에서 서버는 CLOSE_WAIT 상태, 클라이언트는 FIN_WAIT_2 상태**

### **STEP 3: Server → Client : FIN**

- **서버가 자신의 모든 데이터를 송신 완료한 후**
- **서버는 연결 종료를 확정짓기 위해 FIN 플래그가 설정된 패킷을 클라이언트로 보냄**
- **서버도 이제 더 이상 데이터를 전송하지 않겠다는 의사를 전달하며, 자신의 연결을 종료**
- **서버는 LAST_ACK 상태로 들어가, 클라이언트로부터 최종 ACK 응답을 기다림**

### **STEP 4: Client → Server : ACK**

- **클라이언트가 서버로부터 도착한 FIN 패킷을 받음**
- **클라이언트는 이에 대해 다시 ACK 패킷을 서버에 전송**
- **클라이언트는 서버의 종료 요청을 확인하며, 이때부터 양쪽의 연결은 완전히 종료되기 위한 마지막 준비 단계에 들어감**
- **클라이언트는 TIME_WAIT 상태에 진입, 이 상태는 일정 시간 동안 네트워크상의 지연 패킷 등으로 인한 오류나 혼동을 방지하기 위함. 시간이 지나면 클라이언트 측 소켓은 CLOSED 상태가 됨**

![](https://blog.kakaocdn.net/dn/cbRERE/btr1IqW6iFD/UEUttQCV5oD9hj9SXDX2Jk/img.png)

## 작동 방식(Abrupt)

> 예상치 못한 상황이나 오류 발생 시, 연결을 즉시 종료하기 위해 RST(Reset) 패킷을 사용한다.
> 
- **비정상적 데이터 수신:** 존재하지 않는 연결에 대해 비SYN 세그먼트가 도착한 경우
- **헤더 오류 감지:** TCP 헤더에 오류가 있어 세그먼트가 올바르지 않을 때
- **연결 유지 불능:** 시스템 자원이 부족하거나, 원격 호스트와의 연결이 불안정하여 응답이 중지될 때

이 경우, 연결은 즉시 강제로 종료되며 정상적인 4-way handshake 절차는 진행되지 않는다.

---

**3-way handshake는 TCP 연결 설정에 사용되며, SYN → SYN-ACK → ACK의 3단계 메시지 교환을 통해 연결을 확립한다. 4-way handshake는 TCP 연결 종료에 사용되며, FIN/ACK 메시지의 4단계 교환을 통해 양쪽이 안전하게 연결을 종료할 수 있도록 한다. 이와 같이 두 절차는 데이터 전송의 시작과 끝에서 네트워크 통신의 신뢰성, 안정성을 보장하기 위한 중요한 역할을 한다.**
