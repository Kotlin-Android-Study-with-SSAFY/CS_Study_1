# PCB와 Context Switching Read.me

Date: 2025년 3월 13일
Status: ...Ready...

## **PCB (Process Control Block) ?**

> 프로세스의 메타데이터(각종 정보들)를 저장하는 곳 
운영체제(OS)는 PCB를 이용해서 각 프로세스를 관리하고, 필요할 때 정보를 가져와 실행한다.
> 
- **하나의 프로세스당 하나의 PCB**가 생성됨.
- **프로세스 상태, 프로그램 카운터, CPU 레지스터 정보** 등을 저장.
- **프로세스가 생성될 때 PCB가 생성**되고, **프로세스가 종료되면 PCB도 제거**됨.
- **Linked List 방식으로 관리됨** (삽입, 삭제 용이).

### WHY? PCB가 필요할까?

> CPU는 한 번에 하나의 프로세스만 실행할 수 있다. 
우리가 컴퓨터를 사용하면서 여러 작업을 동시에 하는 것처럼 보이는 이유는
CPU가 여러 프로세스를 빠르게 전환(스위칭)하면서 실행하기 때문이다.
> 

CPU가 다른 프로세스를 실행하기 위해 기존 프로세스를 중단할 때, 기존 프로세스의 상태를 기억해야 다시 이어서 실행할 수 있다. 

<aside>

📌 CPU가 다른 프로세스를 실행할 때도, 기존 프로세스의 정보를 PCB에 저장해둬서 나중에 다시 실행할 때 이어서 진행할 수 있게 해주는 것이 PCB의 핵심 역할이다. 

</aside>

---

## **PCB의 주요 정보**

> **프로세스들이 다시 실행할 때 필요한 정보들**
> 
- **Process State** : 현재 프로세스의 상태 (Ready, Running, Block 등) 저장
    - 주요 상태
        - **New**: 생성된 상태 (아직 실행되진 않음).
        - **Ready**: 실행될 준비가 된 상태 (CPU를 기다리는 중).
        - **Running**: CPU를 할당받아서 실행 중.
        - **Blocked**: 입출력(I/O) 작업 등으로 인해 대기하는 상태.
        - **Terminated**: 실행이 끝난 상태.
- **Program Counter** : 다음에 실행할 명령어의 주소값 저장
    - CPU가 프로세스를 다시 실행할 때 어디서부터 실행해야 하는지를 알려줌
- **CPU Registers** : 프로세스 실행을 위한 CPU 레지스터 값들.
    - CPU가 계산할 때 사용하는 각종 변수 값들이 저장
    - 실행 중이던 프로세스를 멈출 때 현재까지의 계산 값, 연산 정보 등을 저장

---

## **PCB의 역할**

- CPU에서 **프로세스 상태를 변경**할 때 이전 프로세스의 상태를 저장하고, 새로운 프로세스의 상태를 불러오는 역할.
- **인터럽트 발생 시에도 PCB 정보를 활용하여 다시 이어서 실행 가능**.

---

## **Context Switching**

> CPU가 실행 중인 프로세스를 다른 프로세스로 전환하는 과정
현재 프로세스의 상태를 PCB에 저장하고, 새로운 프로세스의 상태를 PCB에서 불러와 실행
> 
- **멀티태스킹, 인터럽트 처리, 사용자-커널 모드 전환 시 발생**.
- **잦은 Context Switching은 오버헤드 발생 가능**.

---

## Context Switching이 왜 필요할까?

> 컴퓨터가 동시에 여러 프로세스를 실행하는 것처럼 보이게 하려면 
CPU가 빠르게 프로세스를 교체해야 한다. 
하지만 CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문에, 
한 프로세스를 실행하다가 다른 프로세스를 실행하려면 Context Switching을 수행해야 한다!
> 
- 우리가 채팅을 하면서 음악을 듣고, 인터넷 검색도 하고 싶을 경우
    
    CPU는 한 번에 하나의 작업만 수행할 수 있어서, 여러 작업을 빠르게 교체하면서 실행한다. 이때, **기존 작업의 상태를 저장하고 새로운 작업의 상태를 불러오는 과정**이 Context Switching이다. 
    

---

## Context Switching이 발생하는 상황

### 멀티 태스킹(MultiTasking)

- **여러 개의 프로세스를 동시에 실행하는 것처럼 보이게 하는 기법**.
- **운영체제(OS)가 CPU를 빠르게 전환**하면서 여러 작업을 처리함.

### 인터럽트 발생(Interrupt Handling)

- 실행 중이던 프로세스가 **입출력(I/O) 작업 요청, 타이머 만료 등의 이유로 중단될 때** 발생한다.
- 예를 들어, 사용자가 **파일을 저장하려고 하면, CPU는 저장 프로세스를 실행하고 기존 프로세스를 잠시 멈춘다.**

### 사용자 모드 → 커널 모드 전환(User Mode → Kernel Mode Switching)

- 운영체제(OS)가 직접 관여해야 하는 작업이 있을 때 발생
- 예를 들어, 파일을 저장하거나 네트워크 작업을 요청하면 OS가 직접 관리해야 하기 때문에 커널 모드로 전환된다.

---

## **Context Switching의 과정**

> CPU가 프로세스를 전환하는 과정
> 

### A → B 프로세스 전환 과정

1. 프로세스 A 실행 중
    - 현재 실행 중인 프로세스 A가 있음
2. 인터럽트 발생(or CPU 시간 만료) 
    - 프로세스 A가 잠시 중단되어야 하는 상황 발생
3. PCB에 프로세스 A의 상태 저장
    - A의 현재 실행 정보를 PCB에 저장 (레지스터 값, 메모리 정보 등)
4. 프로세스 B의 PCB 정보 불러오기 
    - 새롭게 실행할 프로세스 B의 정보를 PCB에서 가져옴
5. 프로세스 B의 실행 시작
    - B의 정보가 CPU에 적재되고 실행됨

<aside>

📌 이러한 과정이 매우 빠르게 반복되면서, 여러 작업이 동시에 실행되는 것처럼 보인다. 

</aside>

---

## Context Switching이 많다면?

> Context Switching은 필수적인 작업이지만, 너무 자주 발생하면 성능 저하가 발생할 수 있다. → CPU가 프로세스를 전환하는 동안 아무 일도 하지 못하기 때문이다.
> 

### Context Switching Cost(비용)

1. **캐시 초기화 (Cache Flush)**
- 새로운 프로세스를 실행하려면 기존 프로세스의 **CPU 캐시를 비우고 새 데이터를 불러와야 함**.
- 캐시를 비우고 다시 로딩하는 과정에서 시간이 걸림.
1. **메모리 매핑 초기화 (Memory Mapping)**
- 프로세스마다 사용하는 메모리 공간이 다르므로, **새로운 프로세스에 맞게 메모리 맵을 변경해야 함**.
1.  **커널 실행 필요**
- 운영체제가 직접 프로세스를 관리해야 하므로, **Context Switching을 처리하는 동안 추가적인 작업이 필요함**.

<aside>

📌 **즉, Context Switching이 너무 많으면 오버헤드(Overhead, 간접 부담 비용)가 발생해서 성능이 저하될 수 있다.**

</aside>

---

## **Context Switching과 프로세스 vs. 스레드**

> Context Switching은 프로세스보다 스레드에서 더 빠르게 수행될 수 있다
→ 스레드는 같은 프로세스 내에서 실행되어 메모리를 공유하기 때문이다.
> 

📌 **비교 정리**

| 항목 | 프로세스(Context Switching) | 스레드(Context Switching) |
| --- | --- | --- |
| 메모리 공유 | ❌ 공유 안 됨 | ✅ 공유됨 |
| Switching 비용 | 높음 (모든 정보 변경) | 낮음 (스택만 변경) |
| 실행 속도 | 느림 | 빠름 |

<aside>

📌  **즉, 스레드 간의 전환 비용이 프로세스보다 적기 때문에, 빠르게 전환이 가능하다**

</aside>

---

## 정리

✔ **PCB란?**

→ **프로세스의 정보를 저장하는 블록** (프로세스의 신분증 같은 역할)

✔ **왜 필요할까?**

→ CPU가 프로세스를 중단했다가 다시 실행할 때, **기존 상태를 유지하고 이어서 실행하기 위함**

✔ **PCB에 저장되는 주요 정보**

- **Process State** : 현재 프로세스 상태 (Ready, Running, Block 등)
- **Program Counter** : 다음 실행할 명령어의 주소
- **CPU Registers** : 실행 중인 프로세스의 CPU 레지스터 값

✔ **PCB의 역할**

→ **Context Switching 시, 프로세스 상태를 저장하고 불러오는 데 사용됨**

✔ **PCB 관리 방식**

→ **Linked List 구조**로 관리 (프로세스 생성 시 추가, 종료 시 삭제)

✔ **Context Switching이란?**

→ CPU가 실행 중인 프로세스를 다른 프로세스로 전환하는 과정

✔ **왜 필요할까?**

→ 멀티태스킹을 위해 여러 프로세스를 빠르게 전환해야 하기 때문이다. 

✔ **언제 발생할까?**

→ 멀티태스킹, 인터럽트 발생, 사용자/커널 모드 전환 시 

✔ **어떻게 동작할까?**

→ 현재 프로세스 상태를 PCB에 저장하고, 새 프로세스 상태를 불러와 실행

✔ **문제점은?**

→ 잦은 Context Switching은 성능 저하(오버헤드) 발생 가능
